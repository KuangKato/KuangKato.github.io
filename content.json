{"meta":{"title":"Better than yesterday","subtitle":null,"description":null,"author":"Kuanger","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-11-29T14:54:45.000Z","updated":"2018-11-29T14:56:33.380Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-11-29T14:55:25.000Z","updated":"2018-11-30T00:43:16.095Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"孔子云：取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。 个人联系方式 Email： kuang_kato@163.com Phone： 13168844985"},{"title":"tags","date":"2018-11-29T14:53:19.000Z","updated":"2018-11-29T14:55:58.165Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java问题快速排查","slug":"Java问题快速排查","date":"2018-11-30T02:54:55.000Z","updated":"2018-11-30T02:54:55.588Z","comments":true,"path":"2018/11/30/Java问题快速排查/","link":"","permalink":"http://yoursite.com/2018/11/30/Java问题快速排查/","excerpt":"这是一篇来源于阿里内部技术论坛的文章，原文在阿里内部获得一致好评。","text":"这是一篇来源于阿里内部技术论坛的文章，原文在阿里内部获得一致好评。 作者：红魔七号 链接：https://yq.aliyun.com/articles/69520?utm_content=m_10360 参考文章： https://mp.weixin.qq.com/s/TMAe3AyOfUQIOf0hGurR4A 原谅小弟不才，有问题可以下方留言指教~ 本文约7000字符，阅读时间约14分钟 – about 14 min read 前言平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。 Linux命令类tail最常用的tail -f 1tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式 grep12345678910grep forest f.txt #文件查找grep forest f.txt cpf.txt #多文件查找grep 'log' /home/admin -r -n #目录下查找所有符合关键字的文件cat f.txt | grep -i shopbase grep 'shopbase' /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀grep 'shopbase' /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配seq 10 | grep 5 -A 3 #上匹配seq 10 | grep 5 -B 3 #下匹配seq 10 | grep 5 -C 3 #上下匹配，平时用这个就妥了cat f.txt | grep -c 'SHOPBASE' awk 基本命令 123456awk '&#123;print $4,$6&#125;' f.txtawk '&#123;print NR,$0&#125;' f.txt cpf.txt awk '&#123;print FNR,$0&#125;' f.txt cpf.txtawk '&#123;print FNR,FILENAME,$0&#125;' f.txt cpf.txtawk '&#123;print FILENAME,\"NR=\"NR,\"FNR=\"FNR,\"$\"NF\"=\"$NF&#125;' f.txt cpf.txtecho 1:2:3:4 | awk -F: '&#123;print $1,$2,$3,$4&#125;' 匹配 1234awk '/ldb/ &#123;print&#125;' f.txt #匹配ldbawk '!/ldb/ &#123;print&#125;' f.txt #不匹配ldbawk '/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;' f.txt #匹配ldb和LISTENawk '$5 ~ /ldb/ &#123;print&#125;' f.txt #第五列匹配ldb 内建变量 NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。 FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。 NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。 find12345678910111213sudo -u admin find /home/admin /tmp /usr -name \\*.log #(多个目录去找)find . -iname \\*.txt #(大小写都匹配)find . -type d #(当前目录下的所有子目录)find /usr -type l #(当前目录下所有的符号链接)find /usr -type l -name \"z*\" -ls #(符号链接的详细信息 eg:inode,目录)find /home/admin -size +250000k #(超过250000k的文件，当然+改成-就是小于了)find /home/admin f -perm 777 -exec ls -l &#123;&#125; \\; #(按照权限查询文件)find /home/admin -atime -1 #1天内访问过的文件find /home/admin -ctime -1 #1天内状态改变过的文件 find /home/admin -mtime -1 #1天内修改过的文件find /home/admin -amin -1 #1分钟内访问过的文件find /home/admin -cmin -1 #1分钟内状态改变过的文件 find /home/admin -mmin -1 #1分钟内修改过的文件 pgm批量查询vm-shopbase满足条件的日志1pgm -A -f vm-shopbase 'cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630' tsar tsar是alibabak开发的一个采集工具，可以上github去clone安装。他可以将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据 https://github.com/alibaba/tsar 12345678910tsar ###可以查看最近一天的各项指标tsar --live ###可以查看实时指标，默认五秒一刷tsar -d 20161218 ###指定查看某天的数据，貌似最多只能看四个月的数据tsar --memtsar --loadtsar --cpu###当然这个也可以和-d参数配合来查询某天的单个指标的情况 toptop除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了12ps -ef | grep javatop -H -p pid 获得线程10进制转16进制后jstack去抓看这个线程到底在干啥 其他12netstat -nat|awk '&#123;print $6&#125;'|sort|uniq -c|sort -rn #查看当前连接，注意close_wait偏高的情况，比如如下 排查利器btrace首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。更详情可以移步到github：https://github.com/btraceio/btrace 查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈 监控当前服务方法被调用时返回的值以及请求的参数 注意: 经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果 正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况 由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。 Greys说几个挺棒的功能(部分功能和btrace重合): sc -df xxx: 输出当前类的详情,包括源码位置和classloader结构 trace class method: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。 javOSize就说一个功能 classes：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。 其他功能Greys和btrace都能很轻易做的到，不说了。 JProfiler之前判断许多问题要通过 JProfiler，但是现在 Greys和 btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。官网请移步https://www.ej-technologies.com/products/jprofiler/overview.html Java Tooljps m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数 l: 输出应用程序主类完整package名称或jar完整名称. v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数 V: 输出通过.hotsportrc或-XX:Flags=指定的jvm参数1sudo -u admin /opt/taobao/java/bin/jps -mlvV jstack 普通用法:1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815 native+java栈:1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815 jinfo可看系统启动的参数，如下1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815 jmap 查看堆的情况 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815 dump 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815 or1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815 看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10 jstatjstat参数众多，但是使用一个就够了1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 jdb时至今日，jdb也是经常使用的。jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000.那么sudo -u admin /opt/taobao/java/bin/jdb -attach 8000. 出现以上代表jdb启动成功。后续可以进行设置断点进行调试。具体参数可见oracle官方说明http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html CHLSDBCHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。1sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB 更详细的可见R大此贴http://rednaxelafx.iteye.com/blog/1847971 jar包冲突把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?1mvn dependency:tree &gt; ~/dependency.txt 打出所有依赖 1mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId 只打出指定groupId和artifactId的依赖关系 1-XX:+TraceClassLoading vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 1-verbose vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 1greys:sc greys的sc命令也能清晰的看到当前类是从哪里加载过来的 1tomcat-classloader-locate 通过以下url可以获知当前类是从哪里加载的 1curl http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObjec 其他dmesg如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。1sudo dmesg|grep -i kill|less 去找关键字oom_killer。找到的结果类似如下:12345[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 [6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 [6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child [6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB 以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。 dmesg日志时间转换公式: log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：1date -d \"1970-01-01 UTC `echo \"$(date +%s)-$(cat /proc/uptime|cut -f 1 -d' ')+12288812.926194\"|bc ` seconds\" 剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。 eclipseMAT可作为eclipse的插件，也可作为单独的程序打开。详情请移步http://www.eclipse.org/mat/ Plugin of intellij idea key promoter maven helper 分析maven依赖的好帮手。 RateLimiter想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。 详情可移步http://ifeve.com/guava-ratelimite Thanks~","categories":[{"name":"问题解决","slug":"问题解决","permalink":"http://yoursite.com/categories/问题解决/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"问题解决","slug":"问题解决","permalink":"http://yoursite.com/tags/问题解决/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-11-28T07:47:17.000Z","updated":"2018-11-29T14:58:32.770Z","comments":true,"path":"2018/11/28/Hello-World/","link":"","permalink":"http://yoursite.com/2018/11/28/Hello-World/","excerpt":"Preface Record the birth of my website 记录一下我的网站的诞生~","text":"Preface Record the birth of my website 记录一下我的网站的诞生~ Homework is stupid,the whole point is to get less of it——Rick 注意： 阅读文章的时候可以点击左上角的Logo，可以对文章的字体调整和选择夜间模式。 PrintHello World! 1System.out.print(\"Hello world\");","categories":[{"name":"welcome","slug":"welcome","permalink":"http://yoursite.com/categories/welcome/"}],"tags":[{"name":"welcome","slug":"welcome","permalink":"http://yoursite.com/tags/welcome/"}]}]}